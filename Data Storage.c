#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<string.h>
//判断本机大小端字节序存储方式
//方法1
//int main()
//{
//	int a = 0x00000001;
//	char* p = &a;
//	*p = 0;//小端会改为0，大端不变
//	if (a == 1)
//	{
//		printf("大端字节序存储\n");
//	}
//	else if (a == 0)
//	{
//		printf("小端字节序存储\n");
//	}
//	return 0;
//}

//方法2
//int main()
//{
//	int a = 0x00000001;
//	char* p = &a;
//	if (*p == 1)
//	{
//		printf("小端字节序存储\n");
//	}
//	else if (*p == 0)
//	{
//		printf("大端字节序存储\n");
//	}return 0;
//
//}

//练习题1
//int main()
//{
//	//-1
//	//1000000000000000000000000000000001 - 原码
//	//1111111111111111111111111111111110 - 反码
//	//1111111111111111111111111111111111 - 补码
//	//char/signed char/unsigned char类型截取低位的8个bit-11111111
//	char a = -1;
//	signed char b = -1;
//	unsigned char c = -1;
//	printf("a=%d\nb=%d\nc=%d\n", a, b, c);
//	//%d按整型输出，需要整型提升
//	//对于char a和signed char b
//	//补码为11111111111111111111111111111111
//	//转为原码10000000000000000000000000000001 - 就是-1
//	//对于unsigned char c
//	//补码为00000000000000000000000011111111 - 因为整型提升补位看符号位，unsigned无符号，默认补0
//	//转为原码也是00000000000000000000000011111111 - 255
//	return 0;
//}
//练习题2
//int main()
//{
//	char a = -128;
//	//10000000
//	printf("%d\n", a);
//	//整型提升，11111111111111111111111110000000 - 补码
//	//10000000000000000000000010000000 - -128
//	printf("%u\n", a);
//	//整型提升，11111111111111111111111110000000 - 因为a的类型是char，有符号位且为1，得到补码，在%u眼中也是原码
//	return 0;
//}
//练习题3
//int main()
//{
//	int a = - 20;
//	//补码-11111111111111111111111111101100
//	unsigned int b = 10;
//	//00000000000000000000000000001010
//	//补码相加
//	//11111111111111111111111111110110
//	//原码10000000000000000000000000001010 - -10
//	printf("%d\n", a + b);
//	return 0;
//}

//练习题4
//#include<windows.h>
//int main()
//{
//	unsigned int i;//i是无符号整型，永远不可能是负数
//	for (i = 9; i >= 0; i--)
//	{
//		printf("%u\n", i);
//		Sleep(1000);
//	}
//	return 0;
//}

//练习题5

//int main()
//{
//	char arr[1000];
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		arr[i] = -1 - i;
//		//-1,-2,...,-128 到-129就超出范围了，计算实际存储为127，接着为126，125，...，2，1，0（\0）
//	}
//	printf("%d\n", strlen(arr));//strlen遇到\0停止读取，故最终结果为255
//}

//练习题6
//int main()
//{
//	unsigned char i = 0;//0~255
//	for (i = 0; i <= 255; i++)//死循环，像这种具有明显范围的，超过这个范围就会重新回到范围内，就有可能是死循环
//	{
//		printf("hehe\n");
//	}
//	return 0;
//}

//练习题7
//int main()
//{
//	if (strlen("abc") - strlen("abcdef") >= 0)
//	//strlen的返回值是size_t的无符号整型，一个无符号整型减一个无符号整型得到的还是无符号整型，这里-3会被转为4294967293
//	//改法，强制类型转化，或者不用减号，直接比较
//	{
//		printf(">");
//	}
//	else
//	{
//		printf("<");
//	}
//	printf("\n%u\n", strlen("abc") - strlen("abcdef"));
//	return 0;
//}

//浮点型数据的存储
//整型类型char,short,long,long long,int引用头文件limits.h,浮点型float，double，long double引用头文件float.h
//int main()
//{
//	int a = 9;
//	float* pfloat = (float*)&a;
//	printf("a=%d\n", a);//a按整型的方式存放，按整型的方式取出，没问题
//	printf("*pfloat=%f\n", *pfloat);//a按整型的方式存放，按浮点型的方式取出，有问题
//	*pfloat = 9.0;//将9按浮点型的方式存放进a
//	printf("a=%d\n", a);//9按浮点型的方式存放，按整型的方式取出，有问题
//	printf("*pfloat=%f\n", *pfloat);//9按浮点型的方式存放，按浮点型的方式取出，没问题
//	return 0;
//}

//实例
int main()
{
	float f = 5.5f;//不加f的话5.5本身是double类型，会被强制类型转化存到float里去，加个f就明确表示5.5是float型
	//101.1
	//S=0;M=1.011;E=2(+127放129)
	//0 10000001 01100000000000000000000
	//0100 0000 1011 0000 0000 0000 0000 0000
	//4    0    b    0    0    0    0    0 - 十六进制
	//0x 40 b0 00 00
	return 0;
}