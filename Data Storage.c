#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
//判断本机大小端字节序存储方式
//方法1
//int main()
//{
//	int a = 0x00000001;
//	char* p = &a;
//	*p = 0;//小端会改为0，大端不变
//	if (a == 1)
//	{
//		printf("大端字节序存储\n");
//	}
//	else if (a == 0)
//	{
//		printf("小端字节序存储\n");
//	}
//	return 0;
//}

//方法2
//int main()
//{
//	int a = 0x00000001;
//	char* p = &a;
//	if (*p == 1)
//	{
//		printf("小端字节序存储\n");
//	}
//	else if (*p == 0)
//	{
//		printf("大端字节序存储\n");
//	}return 0;
//
//}

//练习题1
//int main()
//{
//	//-1
//	//1000000000000000000000000000000001 - 原码
//	//1111111111111111111111111111111110 - 反码
//	//1111111111111111111111111111111111 - 补码
//	//char/signed char/unsigned char类型截取低位的8个bit-11111111
//	char a = -1;
//	signed char b = -1;
//	unsigned char c = -1;
//	printf("a=%d\nb=%d\nc=%d\n", a, b, c);
//	//%d按整型输出，需要整型提升
//	//对于char a和signed char b
//	//补码为11111111111111111111111111111111
//	//转为原码10000000000000000000000000000001 - 就是-1
//	//对于unsigned char c
//	//补码为00000000000000000000000011111111 - 因为整型提升补位看符号位，unsigned无符号，默认补0
//	//转为原码也是00000000000000000000000011111111 - 255
//	return 0;
//}
//练习题2
//int main()
//{
//	char a = -128;
//	//10000000
//	printf("%d\n", a);
//	//整型提升，11111111111111111111111110000000 - 补码
//	//10000000000000000000000010000000 - -128
//	printf("%u\n", a);
//	//整型提升，11111111111111111111111110000000 - 因为a的类型是char，有符号位且为1，得到补码，在%u眼中也是原码
//	return 0;
//}
//练习题3
int main()
{
	int a = - 20;
	//补码-11111111111111111111111111101100
	unsigned int b = 10;
	//00000000000000000000000000001010
	//补码相加
	//11111111111111111111111111110110
	//原码10000000000000000000000000001010 - -10
	printf("%d\n", a + b);
	return 0;
}